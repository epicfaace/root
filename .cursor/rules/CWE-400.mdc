---
description: Guidance to prevent CWE-400 Uncontrolled Resource Consumption
ruleType: Agent Requested
globs: ["**/*.{js,ts}", "**/backend/**/*.{js,ts}"]
---

### CWE-400: Uncontrolled Resource Consumption

Uncontrolled Resource Consumption (also known as Resource Exhaustion) occurs when an application does not properly restrict the consumption of resources, such as memory, CPU, disk space, or network bandwidth, potentially leading to denial of service.

**Prevention Guidance:**
- Implement proper resource limits for all operations
- Add timeouts for long-running operations
- Validate and limit the size of all user inputs
- Implement proper pagination for large data sets
- Use connection pooling for database and external service connections
- Rate-limit API requests from clients
- Implement caching strategies to reduce resource consumption
- Monitor resource usage and implement circuit breakers
- Design for graceful degradation under high load

```good_example
// Express with rate limiting and request size limits
const express = require('express');
const rateLimit = require('express-rate-limit');
const app = express();

// Limit request body size to prevent memory exhaustion
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));

// Rate limiting to prevent abuse
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  standardHeaders: true,
  message: 'Too many requests, please try again later'
});

// Apply rate limiting to API routes
app.use('/api', apiLimiter);

// Pagination for large data sets
app.get('/api/items', async (req, res) => {
  const page = parseInt(req.query.page || '1');
  const limit = parseInt(req.query.limit || '20');
  
  // Enforce reasonable limits
  const sanitizedLimit = Math.min(limit, 100);
  const skip = (page - 1) * sanitizedLimit;
  
  try {
    const items = await Item.find()
      .skip(skip)
      .limit(sanitizedLimit)
      .exec();
      
    const total = await Item.countDocuments();
    
    res.json({
      items,
      pagination: {
        total,
        page,
        pages: Math.ceil(total / sanitizedLimit)
      }
    });
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Timeouts for external service calls
async function fetchExternalData(url) {
  try {
    const response = await fetch(url, {
      timeout: 5000 // 5 second timeout
    });
    
    return await response.json();
  } catch (error) {
    console.error('External API timeout:', error);
    throw new Error('External service unavailable');
  }
}

// Database connection with proper pooling
const mongoose = require('mongoose');
mongoose.connect(process.env.MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
  poolSize: 10, // Limit connection pool size
  connectTimeoutMS: 5000, // Connection timeout
  socketTimeoutMS: 45000 // Socket timeout
});
```

```bad_example
// VULNERABLE: No limits on request body size
const express = require('express');
const app = express();

// VULNERABLE: No request size limits
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// VULNERABLE: No rate limiting
app.post('/api/process', async (req, res) => {
  // Process data without limits
});

// VULNERABLE: No pagination for large data sets
app.get('/api/items', async (req, res) => {
  try {
    // VULNERABLE: Returns all items without pagination
    const items = await Item.find().exec();
    
    res.json(items);
  } catch (error) {
    res.status(500).json({ error: 'Internal server error' });
  }
});

// VULNERABLE: No timeout for external API calls
async function fetchExternalData(url) {
  // VULNERABLE: No timeout, could hang indefinitely
  const response = await fetch(url);
  return await response.json();
}

// VULNERABLE: Regex with potential exponential backtracking
function validateEmail(email) {
  // VULNERABLE: Can cause DoS with certain inputs (ReDoS)
  const emailRegex = /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
  return emailRegex.test(email);
}
```

**Looking at this codebase:**
- Check for proper input size validation in API endpoints
- Verify that pagination is implemented for large data queries
- Look for rate limiting mechanisms for public-facing APIs
- Check for proper timeouts in external service calls
- Verify that proper connection pooling is used for databases
- Look for potential regex denial of service (ReDoS) vulnerabilities
- Check for disk space management in file upload operations
- Verify that long-running operations have timeouts or cancellation mechanisms